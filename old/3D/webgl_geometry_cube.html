<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - geometry - cube</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<script src="node_modules/socket.io-client/dist/socket.io.js"></script>
		<script src="socket.js"></script>
	</head>
	<body>

		<script type="module">

			import * as THREE from './three.module.js';

			let camera, scene, renderer;
			let mesh;
			let lastTime = 0
			const speed = {x: 0, y: 0, z:0}
			const data = {x: 0, y: 0, z: 0}

			init();
			animate();

			function init() {

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.z = 400;



				scene = new THREE.Scene();

				const texture = new THREE.TextureLoader().load( './crate.gif' );

				const geometry = new THREE.BoxBufferGeometry( 200, 200, 200 );
				const material = new THREE.MeshBasicMaterial( { map: texture } );

				mesh = new THREE.Mesh( geometry, material );
				scene.add( mesh );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				//

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function rotate() {
				if (lastTime) {
					let currentTime = Date.now()
					let lambdaTime = (currentTime - lastTime) / 1000

					mesh.rotation.x += speed.x * lambdaTime;
					mesh.rotation.y += speed.y * lambdaTime;
					mesh.rotation.z += speed.z * lambdaTime;


					data.z += speed.z * lambdaTime * (180 / Math.PI)
					// console.log(data.z)

					lastTime = currentTime
				} else {
					lastTime = Date.now()
				}
			}

			function animate() {
				requestAnimationFrame( animate );
				// rotate()
				renderer.render( scene, camera );
			}

			setListenHandler(data => {
				mesh.rotation.x = data.x
				mesh.rotation.y = data.y
				mesh.rotation.z = data.z
			})

			window.mesh = mesh

		</script>

	</body>
</html>
